#include <Windows.h>
#include <mmdeviceapi.h>
#include <endpointvolume.h>
#include <QDebug>

bool toggleMicrophoneMute()
{
    CoInitialize(nullptr);

    IMMDeviceEnumerator* enumerator = nullptr;
    IMMDevice* device = nullptr;
    IAudioEndpointVolume* volume = nullptr;
    BOOL isMuted = FALSE;
    bool success = false;

    if (SUCCEEDED(CoCreateInstance(__uuidof(MMDeviceEnumerator), nullptr, CLSCTX_INPROC_SERVER,
                                   __uuidof(IMMDeviceEnumerator), (void**)&enumerator))) {
        if (SUCCEEDED(enumerator->GetDefaultAudioEndpoint(eCapture, eConsole, &device))) {
            if (SUCCEEDED(device->Activate(__uuidof(IAudioEndpointVolume), CLSCTX_ALL, nullptr, (void**)&volume))) {
                if (SUCCEEDED(volume->GetMute(&isMuted))) {
                    BOOL newMute = !isMuted;
                    if (SUCCEEDED(volume->SetMute(newMute, nullptr))) {
                        qDebug() << (newMute ? "Микрофон выключен" : "Микрофон включен");
                        success = true;
                    }
                }
                volume->Release();
            }
            device->Release();
        }
        enumerator->Release();
    }

    CoUninitialize();
    return success;
}


connect(ui->muteButton, &QPushButton::toggled, this, [](bool checked){
    setMicrophoneMute(checked); // true = выключить, false = включить

    if (checked)
        qDebug() << "Микрофон выключен кнопкой";
    else
        qDebug() << "Микрофон включен кнопкой";
});


# Реализация мута микрофона с использованием PortAudio на C++

Вот полный пример реализации мута микрофона с использованием библиотеки PortAudio:

```cpp
#include <portaudio.h>
#include <iostream>
#include <vector>
#include <atomic>
#include <thread>
#include <chrono>

class MicrophoneMuter {
private:
    PaStream* stream;
    std::atomic<bool> isMuted;
    std::atomic<bool> isRunning;
    std::thread audioThread;

    // Callback функция для обработки аудио
    static int audioCallback(const void* inputBuffer, void* outputBuffer,
                            unsigned long framesPerBuffer,
                            const PaStreamCallbackTimeInfo* timeInfo,
                            PaStreamCallbackFlags statusFlags,
                            void* userData) {
        MicrophoneMuter* self = static_cast<MicrophoneMuter*>(userData);
        float* out = static_cast<float*>(outputBuffer);
        
        if (self->isMuted) {
            // Если микрофон заглушен - заполняем буфер тишиной
            for (unsigned int i = 0; i < framesPerBuffer; i++) {
                *out++ = 0.0f; // левый канал
                *out++ = 0.0f; // правый канал
            }
        } else {
            // Если микрофон не заглушен - передаем входной сигнал на выход
            const float* in = static_cast<const float*>(inputBuffer);
            for (unsigned int i = 0; i < framesPerBuffer; i++) {
                *out++ = *in++; // левый канал
                *out++ = *in++; // правый канал
            }
        }
        
        return paContinue;
    }

    void audioProcessing() {
        while (isRunning) {
            Pa_Sleep(100); // Небольшая задержка для снижения нагрузки на CPU
        }
    }

public:
    MicrophoneMuter() : stream(nullptr), isMuted(false), isRunning(false) {
        // Инициализация PortAudio
        PaError err = Pa_Initialize();
        if (err != paNoError) {
            std::cerr << "PortAudio error: " << Pa_GetErrorText(err) << std::endl;
            return;
        }

        // Настройка параметров потока
        PaStreamParameters inputParameters, outputParameters;
        
        // Входные параметры (микрофон)
        inputParameters.device = Pa_GetDefaultInputDevice();
        if (inputParameters.device == paNoDevice) {
            std::cerr << "Error: No default input device." << std::endl;
            return;
        }
        inputParameters.channelCount = 2; // стерео
        inputParameters.sampleFormat = paFloat32;
        inputParameters.suggestedLatency = Pa_GetDeviceInfo(inputParameters.device)->defaultLowInputLatency;
        inputParameters.hostApiSpecificStreamInfo = nullptr;

        // Выходные параметры (динамики)
        outputParameters.device = Pa_GetDefaultOutputDevice();
        if (outputParameters.device == paNoDevice) {
            std::cerr << "Error: No default output device." << std::endl;
            return;
        }
        outputParameters.channelCount = 2; // стерео
        outputParameters.sampleFormat = paFloat32;
        outputParameters.suggestedLatency = Pa_GetDeviceInfo(outputParameters.device)->defaultLowOutputLatency;
        outputParameters.hostApiSpecificStreamInfo = nullptr;

        // Открытие потока
        err = Pa_OpenStream(&stream,
                           &inputParameters,
                           &outputParameters,
                           44100, // sample rate
                           256,   // frames per buffer
                           paClipOff,
                           audioCallback,
                           this);

        if (err != paNoError) {
            std::cerr << "PortAudio error: " << Pa_GetErrorText(err) << std::endl;
            return;
        }

        // Запуск потока
        err = Pa_StartStream(stream);
        if (err != paNoError) {
            std::cerr << "PortAudio error: " << Pa_GetErrorText(err) << std::endl;
            return;
        }

        isRunning = true;
        audioThread = std::thread(&MicrophoneMuter::audioProcessing, this);
    }

    ~MicrophoneMuter() {
        isRunning = false;
        if (audioThread.joinable()) {
            audioThread.join();
        }

        if (stream) {
            Pa_StopStream(stream);
            Pa_CloseStream(stream);
        }
        Pa_Terminate();
    }

    void toggleMute() {
        isMuted = !isMuted;
        std::cout << "Microphone is now " << (isMuted ? "muted" : "unmuted") << std::endl;
    }

    bool getMuteState() const {
        return isMuted;
    }
};

int main() {
    MicrophoneMuter muter;
    
    std::cout << "Microphone muter application" << std::endl;
    std::cout << "Press 'm' to toggle mute, 'q' to quit" << std::endl;
    
    char input;
    do {
        std::cin >> input;
        if (input == 'm') {
            muter.toggleMute();
        }
    } while (input != 'q');
    
    return 0;
}
```

## Как это работает:

1. **Инициализация PortAudio**: Класс `MicrophoneMuter` инициализирует PortAudio при создании.

2. **Аудио-поток**: Создается аудио-поток с callback-функцией, которая обрабатывает аудиоданные.

3. **Режим мута**: 
   - Когда микрофон не заглушен, callback просто передает входные данные на выход.
   - Когда микрофон заглушен, callback заполняет выходной буфер нулями (тишиной).

4. **Управление**: Метод `toggleMute()` переключает состояние мута.

5. **Очистка**: При уничтожении объекта корректно закрываются все ресурсы.

## Сборка и зависимости:

Для компиляции этого кода вам понадобится:
1. Установленная библиотека PortAudio
2. Команда компиляции может выглядеть так:
   ```bash
   g++ -o microphone_muter microphone_muter.cpp -lportaudio -lpthread
   ```

## Дополнительные улучшения:

1. **Графический интерфейс**: Можно добавить GUI с использованием Qt, GTK или другой библиотеки.

2. **Горячие клавиши**: Реализовать глобальные горячие клавиши для мута.

3. **Индикация**: Добавить визуальную индикацию состояния микрофона.

4. **Запись в файл**: Добавить возможность записи аудио в файл при необходимости.

Этот код предоставляет базовую функциональность мута микрофона, которую можно интегрировать в более крупный проект, такой как RisiP.
