include <iostream>
#include <vector>
#include <fstream>
#include <type_traits>
#include <string>
#include <utility>
#include <variant>
#include <cstring>
#include <cstddef>

using Id = uint64_t;
using Buffer = std::vector<std::byte>;

enum class TypeId : Id {
    Uint,
    Float,
    String,
    Vector
};

class Any;

// ID из Type
template<class T>
constexpr TypeId typeToId() {
    if constexpr (std::is_same_v<T, uint64_t>)
        return TypeId::Uint;
    else if constexpr (std::is_same_v<T, double>)
        return TypeId::Float;
    else if constexpr (std::is_same_v<T, std::string>)
        return TypeId::String;
    else 
        return TypeId::Vector;
}

//Type из ID
template<TypeId id>
struct idToType;
template<> struct idToType<TypeId::Uint>    { using type = uint64_t;         };
template<> struct idToType<TypeId::Float>   { using type = double;           };
template<> struct idToType<TypeId::String>  { using type = std::string;      };
template<> struct idToType<TypeId::Vector>  { using type = std::vector<Any>; };

// Сериализация типов
namespace basicSerialization {
    template<class T>
    void serialize_type(const T& type, Buffer& buffer) {
        // Сериализация базовых типов ( TypyId::Uint, TypyId::Float )
        if constexpr (std::is_same_v<T, uint64_t> || std::is_same_v<T, double>) {
            const auto* ptr = reinterpret_cast<const std::byte*>(&type);
            buffer.insert(buffer.end(), ptr, ptr + sizeof(T));
        }
        // Сериализация std::string ( TypyId::String )
        else if constexpr (std::is_same_v<T, std::string>) {
            uint64_t size = type.size();
            serialize_type(size, buffer);
            const auto* ptr = reinterpret_cast<const std::byte*>(type.data());
            buffer.insert(buffer.end(), ptr, ptr + type.size());
        }
        // Сериализация std::vector<Any> ( TypyId::Vector )
        else if constexpr (std::is_same_v<T, std::vector<Any>>) {
            uint64_t size = type.size();
            serialize_type(size, buffer);
            for (const auto& Ttype : type)
                Ttype.serialize(buffer);
        }
    }
}
// Десериализация типов
namespace basicDeSerialization { 
    template<class T>
    Buffer::const_iterator deserialize_type(Buffer::const_iterator begin, Buffer::const_iterator end, T& type) {
        // Десериализация базовых типов ( TypyId::Uint, TypyId::Float )
        if constexpr (std::is_same_v<T, uint64_t> || std::is_same_v<T, double>) {
            if (std::distance(begin, end) < static_cast<std::ptrdiff_t>(sizeof(T))) {
                throw std::runtime_error("Invalid buffer size");
            }
            std::memcpy(&type, &*begin, sizeof(T));
            return begin + sizeof(T);
        }
        // Десериализация std::string ( TypyId::String )
        else if constexpr (std::is_same_v<T, std::string>) {
            uint64_t size = 0;
            begin = deserialize_type(begin, end, size);
            if (std::distance(begin, end) < static_cast<std::ptrdiff_t>(size)) {
                throw std::runtime_error("Invalid buffer size");
            }
            type.assign(reinterpret_cast<const char*>(&*begin), size);
            return begin + size;
        }
        // Десериализация std::vector<Any> ( TypyId::Vector )
        else if constexpr (std::is_same_v<T, std::vector<Any>>) {
            uint64_t size = 0;
            begin = deserialize_type(begin, end, size);
            type.resize(size);
            for (auto& Ttype : type) {
                begin = Ttype.deserialize(begin, end);
            }
            return begin;
        }
    }
}

//Базовый тип TType
template<class T>
class Wrapper {
public:
    template<class classType, class = std::enable_if_t<std::is_constructible_v<T, classType>>>
    Wrapper(classType&& type) : _type(std::forward<classType>(type)){}
    
    void serialize(Buffer& buffer) {
        Id id = static_cast<Id>(typeToId<T>());
        basicSerialization::serialize_type(id, buffer);
        basicSerialization::serialize_type(_type, buffer);
    }

    Buffer::const_iterator deserialize(Buffer::const_iterator begin, Buffer::const_iterator end) {
        return basicDeSerialization::deserialize_type(begin, end, _type);
    }

    const T& getType() const {
        return _type;
    }

    T& getType() {
        return _type;
    }

private:
    T _type;
};

class IntegerType : public Wrapper<uint64_t> {
public:
    template<typename ...Args>
    IntegerType(Args&&... args) : Wrapper<uint64_t>(std::forward<Args>(args)...) {}
};

class FloatType : public Wrapper<double> {
public:
    template<typename ...Args>
    FloatType(Args&&... args) : Wrapper<double>(std::forward<Args>(args)...) {}
};

class StringType : public Wrapper<std::string> {
public:
    template<typename ...Args>
    StringType(Args&&... args) : Wrapper<std::string>(std::forward<Args>(args)...) {}
};

class VectorType : public Wrapper<std::vector<Any>> {
public:
    template<typename ...Args>
    VectorType(Args&&... args) : Wrapper<std::vector<Any>>(std::forward<Args>(args)...) {}

    template<typename Arg, class = std::enable_if_t<IsValidType<std::decay_t<Arg>>::value>>
    void push_back(Arg&& _val) {
        this->getType().emplace_back(std::forward<Arg>(_val));
    }
};

template<class T>
using IsValidType = std::disjunction<
    std::is_same<T, IntegerType>,
    std::is_same<T, FloatType>,
    std::is_same<T, StringType>,
    std::is_same<T, VectorType>,
    std::is_same<T, Any>>;

class Any {
public:
    template<class T>
    using enabledT = std::enable_if_t<IsValidType<std::decay_t<T>>::value>;

    Any() {};

    template<typename ...Args, class = enabledT<Args...>>
    Any(Args&&... args) {
        using DecayedT = std::decay_t<std::tuple_element_t<0, std::tuple<Args...>>>;
        if constexpr (std::is_same_v<DecayedT, IntegerType> || 
                      std::is_same_v<DecayedT, FloatType>   ||
                      std::is_same_v<DecayedT, StringType>  ||
                      std::is_same_v<DecayedT, VectorType>) {
            this->_data = std::get<0>(std::forward_as_tuple(std::forward<Args>(args)...)).getType();
        }
        else if constexpr (std::is_same_v<DecayedT, Any>) {
            this->_data = std::get<0>(std::forward_as_tuple(std::forward<Args>(args)...))._data;
        }
    }

    void serialize(Buffer& _buff) const {
        std::visit([&_buff](const auto& Ttype) {
            using T = std::decay_t<decltype(Ttype)>;
            Id id = static_cast<Id>(typeToId<T>());
            basicSerialization::serialize_type(id, _buff);
            basicSerialization::serialize_type(Ttype, _buff);
            }, this->_data);
    }

    Buffer::const_iterator deserialize(Buffer::const_iterator _begin, Buffer::const_iterator _end) {
        Id id = 0;
        _begin = basicDeSerialization::deserialize_type(_begin, _end, id);

        switch (static_cast<TypeId>(id)){
        case TypeId::Uint :{
            uint64_t res = 0;
            _begin = basicDeSerialization::deserialize_type(_begin, _end, res);
            this->_data = res;
            break;
        }
        case TypeId::Float: {
            double res = 0;
            _begin = basicDeSerialization::deserialize_type(_begin, _end, res);
            this->_data = res;
            break;
        }
        case TypeId::String: {
            std::string res;
            _begin = basicDeSerialization::deserialize_type(_begin, _end, res);
            this->_data = res;
            break;
        }
        case TypeId::Vector:{
            std::vector<Any> res;
            _begin = basicDeSerialization::deserialize_type(_begin, _end, res);
            this->_data = res;
            break;
        }
        default:
            throw std::runtime_error("Error with type id");
            break;
        }
        return _begin;
    }

    TypeId getPayloadTypeId() const {
        return static_cast<TypeId>(this->_data.index());
    }

    template<typename Type>
    auto& getValue() const {
        return std::get<Type>(this->_data);
    }

    template<TypeId kId>
    auto& getValue() const {
        return std::get<idToType<kId>::type>(this->_data);
    }

    bool operator == (const Any& _o) const {
        return this->_data == _o._data;
    }
private:
    //Типы под теме же индексами, что и в enum TypeId
    std::variant<uint64_t, double, std::string, std::vector<Any>> _data;
};

class Serializator {
public:
    template<class T>
    using enabledT = std::enable_if_t<IsValidType<std::decay_t<T>>::value>;

    template<typename Arg, class = enabledT<Arg>>
    void push(Arg&& _val) {
        this->_data.emplace_back(std::forward<Arg>(_val));
    }

    Buffer serialize() const {
        Buffer buffer;
        uint64_t size = _data.size();
        basicSerialization::serialize_type(size, buffer);
        for (const auto& TType : _data) {
            TType.serialize(buffer);
        }
        return buffer;
    }

    static std::vector<Any> deserialize(const Buffer& _val) {
        std::vector<Any> result;
        auto iter = _val.begin();
        uint64_t size = 0;
        iter = basicDeSerialization::deserialize_type(iter, _val.end(), size);
        result.reserve(size);
        for (size_t i = 0; i < size; ++i) {
            Any any;
            iter = any.deserialize(iter, _val.end());
            result.push_back(any);
        }
        return result;
    }

    const std::vector<Any>& getStorage() const {
        return _data;
    }
private:
    std::vector<Any> _data;
};

int main() {

    std::ifstream raw;
    raw.open("raw.bin", std::ios_base::in | std::ios_base::binary);
    if (!raw.is_open())
        return 1;
    raw.seekg(0, std::ios_base::end);
    std::streamsize size = raw.tellg();
    raw.seekg(0, std::ios_base::beg);

    Buffer buff(size);
    raw.read(reinterpret_cast<char*>(buff.data()), size);
    raw.close();
    try {
        auto res = Serializator::deserialize(buff);

        Serializator s;
        for (auto&& i : res)
            s.push(i);

        std::cout << (buff == s.serialize()) << '\n';
    }
    catch (std::exception& ex) {
        std::cerr << ex.what() << std::endl;
    }

    return 0;
}